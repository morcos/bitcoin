#!/usr/bin/env python

#
# Test fee estimation code
#

from decimal import ROUND_UP
from test_framework import BitcoinTestFramework
from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException
from util import *

def split_input_by10_tx(from_node, from_addresses, inputs, max_coin, min_coin, fee_split):
    """
    Return the inputs and outputs to a transaction that is created by attempting to 
    split up by a factor of 10 the first input greater than min_coin and less than max coin
    requires 10 from_addresses
    """
    utxo = from_node.listunspent(1)
    inputs = []
    outputs = {}
    while len(utxo) > 0 and len(inputs) == 0:
        t = utxo.pop()
        if t["amount"] > min_coin and t["amount"] <= max_coin:
            qchange =  Decimal(t["amount"]/10).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)
            remchange = t["amount"] - 9*qchange - fee_split
            inputs.append({ "txid" : t["txid"], "vout" : t["vout"], "address" : t["address"] } )
            for i in range(9):
                outputs[from_addresses[i]] = qchange 
            outputs[from_addresses[9]] = remchange 
    return (inputs,outputs)


def split_all_inputs(from_node, max_coin, min_coin, split_fee, max_splits):
    """
    Keep creating and sending transactions until we've split all the inputs
    in the utxo or created max_splits tx's, then return how many transactions were sent
    """
    utxo = from_node.listunspent(1)
    uutxo = from_node.listunspent(0)
    from_addresses = []
    for i in range(10):
        from_addresses.append(from_node.getnewaddress())
    (inputs, outputs) = split_input_by10_tx(from_node, from_addresses, utxo, max_coin, min_coin, split_fee)
    txcount = 0
    
    while (len(inputs) > 0 and txcount < max_splits):
        rawtx = from_node.createrawtransaction(inputs, outputs)
        signresult = from_node.signrawtransaction(rawtx)
        txid = from_node.sendrawtransaction(signresult["hex"], True)
        txcount += 1
        (inputs, outputs) = split_input_by10_tx(from_node, from_addresses, utxo, max_coin, min_coin, split_fee)
         
    return txcount;

def split_inputs_by(nodes, repetitions, mining_node):
    """
    For all the nodes, go through the utxo and split 1 input of size 50 or smaller
    Split by 10 and repeat repetitions times, but don't split below .01
    Each iteration, only split coins that are small enough to have been generated by last
    iteration. And split enough coins that you could have split all the ones previously generated
    """
    for node in nodes:
        divisor = 1
        for j in range(repetitions):
            maxcoin = Decimal(50.0/divisor).quantize(Decimal('0.00000001'),rounding=ROUND_UP)
            split_all_inputs(node,maxcoin,Decimal("0.01"), Decimal("0.0001"),divisor)
            divisor = 10*divisor
            time.sleep(1) #have to let transactions propogate until we start mining
            while len(mining_node.getrawmempool()) > 0:
                mining_node.setgenerate(True, 1)
                sync_blocks(nodes+[mining_node])

class EstimateFeeTest(BitcoinTestFramework):

    def setup_network(self, test_dir):
        nodes = []
        #Use node0 to mine blocks for input splitting temporarily (note this is nodes[0])
        nodes.append(start_node(0, test_dir, ""))

        # Node1 mines small-but-not-tiny blocks, and allows free transactions.
        # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,
        # (20k is room enough for 60 or so transactions)
        nodes.append(start_node(1, test_dir,
                                ["-blockprioritysize=1500", "-blockmaxsize=20000"]))
        connect_nodes(nodes[1], 0)

        # Node2 is a stingy miner, that
        # produces very small blocks (room for only 30 or so transactions)
        node2args = [ "-blockprioritysize=0", "-blockmaxsize=10000"]
        nodes.append(start_node(2, test_dir, node2args))
        connect_nodes(nodes[2], 0)
        
        sync_blocks(nodes)

        print("This test is time consuming, please be patient")
        print("Splitting inputs to small size so we can generate low priority tx's")
        split_inputs_by(nodes[1:], 3, nodes[0])
        print("Finished splitting")

        stop_node(nodes[0],0)
         
        # now replace nodes[0] with node3 without having polluted the estimates
        nodes[0] = start_node(3, test_dir,
                              ["-debug=estimatefee"])
        connect_nodes(nodes[1], 3)  #reconnect now that we removed the one they were connected too
        connect_nodes(nodes[2], 3)
        sync_blocks(nodes)

        return nodes
        

    def run_test(self, nodes):
        min_fee = Decimal("0.00001")
        fees_per_kb = []
        inputlists = []
        from_addresses = []
        to_addresses = []
        for i in range(len(nodes)):
            utxo = nodes[i].listunspent(1)
            random.shuffle(utxo)
            inputlists.append(utxo)
            to_addresses.append(nodes[i].getnewaddress())
            from_addresses.append(nodes[i].getnewaddress())

        print("Creating transactions and mining them with a block size that can't keep up")
        #Create transactions and mine them, but create faster than we can mine
        for i in range(1500):
            from_index = random.randint(1,2)
            to_index = random.randint(1,2)
            (txid, newinputlist, txhex, fee) = small_tx_from_inputs_randfee(nodes[from_index], from_addresses[from_index],
                                                                            to_addresses[to_index], inputlists[from_index],
                                                                            Decimal("0.011"), Decimal("0.05"), min_fee, min_fee, 200)
            inputlists[from_index] = newinputlist
            if (i%65 == 0):
                nodes[2].setgenerate(True, 1)
                sync_blocks(nodes)
            tx_kbytes = (len(txhex)/2)/1000.0
            fees_per_kb.append(float(fee)/tx_kbytes)

        # Mine blocks with node2 until the memory pool clears:
        count_start = nodes[2].getblockcount()
        while len(nodes[2].getrawmempool()) > 0:
            nodes[2].setgenerate(True, 1)
            sync_blocks(nodes)

        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]
        print("Fee estimates, super-stingy miner: "+str([str(e) for e in all_estimates]))

        # Estimates should be within the bounds of what transactions fees actually were:
        delta = 1.0e-6 # account for rounding error
        for e in filter(lambda x: x >= 0, all_estimates):
            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):
                raise AssertionError("Estimated fee (%f) out of range (%f,%f)"%(float(e), min(fees_per_kb), max(fees_per_kb)))

        print("Creating transactions and mining them at a block size that is almost big enough")
        # Generate transactions while mining 50 more blocks, this time with node0
        # which mines at about the rate that transactions are being created
        for i in range(50):
            for j in range(random.randrange(65-40,65+40)):
                from_index = random.randint(1,2)
                to_index = random.randint(1,2)
                (txid, newinputlist, txhex, fee) = small_tx_from_inputs_randfee(nodes[from_index], from_addresses[from_index],
                                                                                to_addresses[to_index], inputlists[from_index],
                                                                                Decimal("0.011"), Decimal("0.05"), Decimal("0.0"), min_fee, 200)
                inputlists[from_index] = newinputlist
                tx_kbytes = (len(txhex)/2)/1000.0
                fees_per_kb.append(float(fee)/tx_kbytes)
            time.sleep(.5)
            nodes[1].setgenerate(True, 1)
            sync_blocks(nodes)
     
        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]
        print("Fee estimates, more generous miner: "+str([ str(e) for e in all_estimates]))

        # Estimates should be within the bounds of what transactions fees actually were:
        delta = 1.0e-6 # account for rounding error

        for e in filter(lambda x: x >= 0, all_estimates):
            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):
                raise AssertionError("Estimated fee (%f) out of range (%f,%f)"%(float(e), min(fees_per_kb), max(fees_per_kb)))

        # Finish by mining a normal-sized block:
        while len(nodes[0].getrawmempool()) > 0:
            nodes[0].setgenerate(True, 1)
            sync_blocks(nodes)

        final_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]
        print("Final fee estimates: "+str([ str(e) for e in final_estimates]))

        # Estimates should be within the bounds of what transactions fees actually were:
        delta = 1.0e-6 # account for rounding error
        for e in filter(lambda x: x >= 0, all_estimates):
            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):
                raise AssertionError("Estimated fee (%f) out of range (%f,%f)"%(float(e), min(fees_per_kb), max(fees_per_kb)))


if __name__ == '__main__':
    EstimateFeeTest().main()
